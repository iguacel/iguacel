{"version":3,"sources":["hooks/useEventListener.js","exp/Exp12.js","hooks/useSmallSize.js"],"names":["eventName","handler","element","window","savedHandler","useRef","useEffect","current","addEventListener","eventListener","event","removeEventListener","size","useSmallSize","canvas","requestRef","dark","useContext","ThemeContext","requestAnimationFrame","animationLoop","cancelAnimationFrame","dx","dy","x","y","paddleX","rightPressed","leftPressed","brickOffsetLeft","brickPadding","score","lives","handleKeyDown","useCallback","keyCode","handleKeyUp","useEventListener","relativeX","clientX","offsetLeft","paddleWidth","colors","main","bricks","c","r","status","ctx","getContext","ratio","devicePixelRatio","width","height","style","scale","clearRect","beginPath","fillStyle","arc","Math","PI","fill","closePath","drawBall","rect","drawPaddle","brickX","brickY","drawBricks","b","brickRowCount","console","log","document","location","reload","collisionDetection","font","fillText","drawScore","drawLives","display","justifyContent","alignItems","border","ref","isClient","getSize","innerWidth","innerHeight","undefined","useState","windowSize","setWindowSize","handleResize"],"mappings":"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","file":"static/js/25.d45dd6ea.chunk.js","sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'react';\n\n// Hook\nexport default (eventName, handler, element = window) => {\n  // Create a ref that stores handler\n  const savedHandler = useRef();\n\n  // Update ref.current value if handler changes.\n  // This allows our effect below to always get latest handler ...\n  // ... without us needing to pass it in effect deps array ...\n  // ... and potentially cause effect to re-run every render.\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(\n    () => {\n      // Make sure element supports addEventListener\n      // On\n      const isSupported = element && element.addEventListener;\n      if (!isSupported) return;\n\n      // Create event listener that calls handler function stored in ref\n      const eventListener = event => savedHandler.current(event);\n\n      // Add event listener\n      element.addEventListener(eventName, eventListener);\n\n      // Remove event listener on cleanup\n      return () => {\n        element.removeEventListener(eventName, eventListener);\n      };\n    },\n    [eventName, element] // Re-run if eventName or element changes\n  );\n};","import React, { useEffect, useContext, useCallback, useRef } from \"react\";\nimport useEventListener from \"../hooks/useEventListener\";\nimport useSmallSize from \"../hooks/useSmallSize\";\nimport ThemeContext from \"../context/ThemeContext\";\n\nexport default () => {\n  const size = useSmallSize();\n  const canvas = useRef(null);\n  const requestRef = useRef();\n  const { dark } = useContext(ThemeContext);\n\n  useEffect(() => {\n    requestRef.current = requestAnimationFrame(animationLoop);\n    return () => cancelAnimationFrame(requestRef.current);\n  }); // Make sure the effect runs only once\n\n  // Ball\n  const ballRadius = 10;\n  let dx = 4;\n  let dy = -4;\n  let x = size / 2;\n  let y = size - 200;\n\n  // Paddle\n  let paddleHeight = 20;\n  let paddleWidth = 75;\n  let paddleX = size / 2;\n  let paddleY = 100;\n\n  // Controls\n  let rightPressed = false;\n  let leftPressed = false;\n\n  // Bricks\n  let brickRowCount = 4;\n  let brickColumnCount = 4;\n  let brickWidth = 75;\n  let brickHeight = 20;\n  let brickPadding = 10;\n  let brickOffsetTop = 100;\n  let brickOffsetLeft =\n    size / 2 -\n    ((brickWidth + brickPadding) * brickColumnCount) / 2 +\n    brickPadding / 2;\n\n  // State\n  let score = 0;\n  let lives = 3;\n\n  // Handlers\n  const handleKeyDown = useCallback(({ keyCode }) => {\n    if (keyCode === 39) {\n      rightPressed = true;\n    } else if (keyCode === 37) {\n      leftPressed = true;\n    }\n  }, []);\n\n  const handleKeyUp = useCallback(({ keyCode }) => {\n    if (keyCode === 39) {\n      rightPressed = false;\n    } else if (keyCode === 37) {\n      leftPressed = false;\n    }\n  }, []);\n\n  function handleMouse({ clientX }) {\n    let relativeX = clientX - canvas.current.offsetLeft;\n    if (relativeX > 0 && relativeX < size) {\n      paddleX = relativeX - paddleWidth / 2;\n    }\n  }\n\n  // Add event listener using our hook\n  useEventListener(\"keydown\", handleKeyDown);\n  useEventListener(\"keyup\", handleKeyUp);\n  useEventListener(\"mousemove\", handleMouse);\n\n  function collisionDetection() {\n    for (c = 0; c < brickColumnCount; c++) {\n      for (r = 0; r < brickRowCount; r++) {\n        let b = bricks[c][r];\n        if (b.status === 1) {\n          if (\n            x > b.x &&\n            x < b.x + brickWidth &&\n            y > b.y &&\n            y < b.y + brickHeight\n          ) {\n            dy = -dy;\n            b.status = 0;\n            score++;\n            if (score === brickRowCount * brickColumnCount) {\n              console.log(\"YOU WIN\");\n              document.location.reload();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function drawScore(ctx) {\n    ctx.font = \"bold 30px Inter\";\n    ctx.fillStyle = colors.main;\n    ctx.fillText(score, 35, 40);\n  }\n  function drawLives(ctx) {\n    ctx.fillText(lives, size - 65, 40);\n  }\n\n  // Colors\n  const colors = {\n    main: dark ? \"RGBA(228, 230, 234, 1.00)\" : \"RGBA(62, 62, 62, 1.00)\",\n  };\n\n  let bricks = [];\n  for (var c = 0; c < brickColumnCount; c++) {\n    bricks[c] = [];\n    for (var r = 0; r < brickRowCount; r++) {\n      bricks[c][r] = { x: 0, y: 0, status: 1 };\n    }\n  }\n\n  const drawBall = (ctx) => {\n    ctx.beginPath();\n    ctx.fillStyle = colors.main;\n    ctx.arc(x, y, ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.closePath();\n  };\n\n  const drawPaddle = (ctx) => {\n    ctx.beginPath();\n    ctx.rect(paddleX, size - paddleY, paddleWidth, paddleHeight);\n    ctx.fillStyle = colors.main;\n    ctx.fill();\n    ctx.closePath();\n  };\n\n  const drawBricks = (ctx) => {\n    for (var c = 0; c < brickColumnCount; c++) {\n      for (var r = 0; r < brickRowCount; r++) {\n        if (bricks[c][r].status === 1) {\n          let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;\n          let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;\n          bricks[c][r].x = brickX;\n          bricks[c][r].y = brickY;\n          ctx.beginPath();\n          ctx.rect(brickX, brickY, brickWidth, brickHeight);\n          ctx.fillStyle = colors.main;\n          ctx.fill();\n          ctx.closePath();\n        }\n      }\n    }\n  };\n\n  // DRAW\n  const animationLoop = () => {\n    const ctx = canvas.current.getContext(\"2d\");\n\n    // Scale\n    const ratio = window.devicePixelRatio || 1;\n\n    canvas.current.width = size * ratio;\n    canvas.current.height = size * ratio;\n\n    canvas.current.style.width = `${size}px`;\n    canvas.current.style.height = `${size}px`;\n\n    ctx.scale(ratio, ratio);\n\n\n    ctx.clearRect(0, 0, size, size); // clear canvas\n\n    drawBall(ctx);\n    drawPaddle(ctx);\n    drawBricks(ctx);\n    collisionDetection();\n    drawScore(ctx);\n    drawLives(ctx);\n\n    // Mov\n    x += dx;\n    y += dy;\n\n    if (x + dx > size - ballRadius || x + dx < ballRadius) {\n      dx = -dx;\n    }\n    if (y + dy < ballRadius) {\n      dy = -dy;\n    } else if (y + dy + paddleY > size - ballRadius) {\n      // Paddle\n      if (x > paddleX && x < paddleX + paddleWidth) {\n        dy = -dy;\n      } else {\n        lives--;\n        if (!lives) {\n          console.log(\"GAME OVER\");\n          document.location.reload();\n        } else {\n          x = size / 2;\n          y = size / 2;\n          dx = 3;\n          dy = -3;\n          paddleX = (size - paddleWidth) / 2;\n        }\n      }\n    }\n\n    if (rightPressed && paddleX < size - paddleWidth) {\n      paddleX += 7;\n    } else if (leftPressed && paddleX > 0) {\n      paddleX -= 7;\n    }\n\n    // console.log(y > size - paddleY)\n\n    // Loop\n    requestRef.current = requestAnimationFrame(animationLoop);\n  };\n\n  return (\n    <div\n      style={{\n        width: \"100%\",\n        height: \"100vh\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <canvas\n        style={{\n          size: \"100%\",\n          border: `${paddleHeight}px solid ${colors.main}`,\n        }}\n        ref={canvas}\n        width={size}\n        height={size}\n      />\n    </div>\n  );\n};\n","import { useState, useEffect } from 'react';\n\nfunction useSmallSize() {\n  const isClient = typeof window === 'object';\n\n  function getSize() {\n    return isClient ? window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth : undefined;\n  }\n\n  const [windowSize, setWindowSize] = useState(getSize);\n\n  useEffect(() => {\n    if (!isClient) {\n      return false;\n    }\n\n    function handleResize() {\n      setWindowSize(getSize());\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return windowSize;\n}\n\nexport default useSmallSize;"],"sourceRoot":""}