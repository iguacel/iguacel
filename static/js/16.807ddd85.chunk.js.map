{"version":3,"sources":["exp/Exp10.js"],"names":["scratchObj","THREE","scratchColor","Cylinders","colors","ref","useRef","attrib","refPlaneMesh","n","colorsArray","Float32Array","grid","useMemo","Array","fill","map","_","i","id","isEven","x","Math","floor","y","col","colIsEven","useFrame","state","time","clock","getElapsedTime","current","visible","rotation","degreesToRadians","position","set","camera","z","dark","main","updateMatrix","setMatrixAt","matrix","instanceMatrix","needsUpdate","toArray","updateProjectionMatrix","elapsedTime","args","attach","attachObject","attachArray","vertexColors","emissiveIntensity","color","useContext","ThemeContext","orthographic","pixelRatio","window","devicePixelRatio","style","width","height","top","left","right","bottom","gl","antialias","alpha","zoom","onCreated","setClearColor","intensity"],"mappings":"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","file":"static/js/16.807ddd85.chunk.js","sourcesContent":["import * as THREE from \"three\";\nimport React, { useRef, useMemo, useContext } from \"react\";\nimport { Canvas, useFrame } from \"react-three-fiber\";\nimport ThemeContext from \"../context/ThemeContext\";\nimport { degreesToRadians } from \"../utils/utils\";\n\nconst scratchObj = new THREE.Object3D();\nconst scratchColor = new THREE.Color();\n\nconst Cylinders = ({ colors }) => {\n  const ref = useRef();\n  const attrib = useRef();\n  const refPlaneMesh = useRef();\n\n  const n = 31;\n  const spacing = 10;\n  const nInstances = n * n;\n\n  const colorsArray = new Float32Array(n * n * 3);\n\n  const grid = useMemo(() =>\n    new Array(n * n).fill(0).map((_, i) => ({\n      id: i,\n      isEven: i % 2 === 0,\n      x: Math.floor(i % n) * spacing - ((spacing * n) / 2 - spacing / 2),\n      y: Math.floor(i / n) * spacing - ((spacing * n) / 2 - spacing / 2),\n      col: Math.floor(i / n),\n      colIsEven: Math.floor(i / n) % 2 === 0,\n    }), [])\n  );\n\n  useFrame((state) => {\n    let time = state.clock.getElapsedTime();\n\n    if (time < 5) {\n      refPlaneMesh.current.visible = false;\n    } else {\n      refPlaneMesh.current.visible = true;\n    }\n\n    // map\n    grid.map((x) => {\n      const rotation = degreesToRadians((time / 10) * 360);\n      scratchObj.position.set(x.x, x.y, 0);\n\n      state.camera.rotation.z = degreesToRadians((time / 10) * 90);\n\n      // Even\n      if (x.isEven) {\n        scratchColor.set(colors.dark);\n\n        if (x.colIsEven) {\n          scratchObj.rotation.x = rotation;\n        } else {\n          scratchObj.rotation.x = -rotation;\n        }\n\n        if (time > 5) {\n          scratchObj.rotation.x = 0;\n          scratchObj.position.set(-200, -200, -200);\n        }\n      }\n\n      // Odd\n      if (!x.isEven) {\n        scratchColor.set(colors.main);\n\n        if (!x.colIsEven) {\n          scratchObj.rotation.x = -rotation;\n        } else {\n          scratchObj.rotation.x = rotation;\n        }\n\n        if (time < 5) {\n          scratchObj.rotation.x = 0;\n          scratchObj.position.set(-200, -200, -200);\n        }\n      }\n\n      scratchObj.updateMatrix();\n      ref.current.setMatrixAt(x.id, scratchObj.matrix);\n      ref.current.instanceMatrix.needsUpdate = true;\n\n      scratchColor.toArray(colorsArray, x.id * 3);\n      attrib.current.needsUpdate = true;\n\n      state.camera.updateProjectionMatrix();\n    });\n    // End map\n\n    if (time > 10) {\n      state.clock.elapsedTime = 0;\n    }\n  });\n  // End useFrame\n\n  return (\n    <group>\n      <instancedMesh ref={ref} args={[null, null, nInstances]}>\n        <cylinderBufferGeometry attach=\"geometry\" args={[5, 5, 10, 32]}>\n          <instancedBufferAttribute\n            ref={attrib}\n            attachObject={[\"attributes\", \"color\"]}\n            args={[colorsArray, 3]}\n          />\n        </cylinderBufferGeometry>\n        <meshBasicMaterial\n          attachArray=\"material\"\n          vertexColors={THREE.VertexColors}\n        />\n        <meshLambertMaterial\n          attachArray=\"material\"\n          emissiveIntensity={2}\n          vertexColors={THREE.VertexColors}\n        />\n        <meshLambertMaterial\n          attachArray=\"material\"\n          emissiveIntensity={2}\n          vertexColors={THREE.VertexColors}\n        />\n      </instancedMesh>\n\n      <mesh position={[0, 0, -10]} ref={refPlaneMesh}>\n        <planeBufferGeometry attach=\"geometry\" args={[820, 820, 1]} />\n        <meshBasicMaterial attach=\"material\" color={colors.dark} />\n      </mesh>\n    </group>\n  );\n};\n\nexport default () => {\n  const { dark } = useContext(ThemeContext);\n\n  const colors = {\n    dark: dark ? \"#1A1E21\" : \"#212733\",\n    main: \"#4DC0CB\",\n  };\n\n  return (\n    <Canvas\n      orthographic\n      pixelRatio={window.devicePixelRatio === 1 ? 1 : 2}\n      style={{\n        position: \"fixed\",\n        width: \"100%\",\n        height: \"100vh\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n      }}\n      gl={{ antialias: true, alpha: false }}\n      camera={{\n        zoom: 8,\n        position: [0, 0, 200],\n      }}\n      onCreated={({ gl }) => {\n        gl.setClearColor(new THREE.Color(colors.main));\n      }}\n    >\n      <hemisphereLight intensity={0.9} />\n      <spotLight position={[0, 0, 400]} intensity={2} />\n\n      <Cylinders colors={colors} />\n    </Canvas>\n  );\n};\n"],"sourceRoot":""}