{"version":3,"sources":["hooks/useSmallSize.js","hooks/useEventListener.js","exp/Exp12.js"],"names":["useSmallSize","isClient","window","getSize","innerWidth","innerHeight","undefined","useState","windowSize","setWindowSize","useEffect","handleResize","addEventListener","removeEventListener","eventName","handler","element","savedHandler","useRef","current","eventListener","event","size","canvas","requestRef","dark","useContext","ThemeContext","requestAnimationFrame","animationLoop","cancelAnimationFrame","dx","dy","x","y","paddleX","rightPressed","leftPressed","brickOffsetLeft","brickPadding","score","lives","handleKeyDown","useCallback","keyCode","handleKeyUp","useEventListener","relativeX","clientX","offsetLeft","paddleWidth","colors","main","bricks","c","r","status","ctx","getContext","ratio","devicePixelRatio","width","height","style","scale","clearRect","beginPath","fillStyle","arc","Math","PI","fill","closePath","drawBall","rect","drawPaddle","brickX","brickY","drawBricks","b","brickRowCount","console","log","document","location","reload","collisionDetection","font","fillText","drawScore","drawLives","display","justifyContent","alignItems","border","ref"],"mappings":"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","file":"static/js/35.3573e424.chunk.js","sourcesContent":["import { useState, useEffect } from 'react';\n\nfunction useSmallSize() {\n  const isClient = typeof window === 'object';\n\n  function getSize() {\n    return isClient ? window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth : undefined;\n  }\n\n  const [windowSize, setWindowSize] = useState(getSize);\n\n  useEffect(() => {\n    if (!isClient) {\n      return false;\n    }\n\n    function handleResize() {\n      setWindowSize(getSize());\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return windowSize;\n}\n\nexport default useSmallSize;","import { useState, useRef, useEffect, useCallback } from 'react';\n\n// Hook\nexport default (eventName, handler, element = window) => {\n  // Create a ref that stores handler\n  const savedHandler = useRef();\n\n  // Update ref.current value if handler changes.\n  // This allows our effect below to always get latest handler ...\n  // ... without us needing to pass it in effect deps array ...\n  // ... and potentially cause effect to re-run every render.\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(\n    () => {\n      // Make sure element supports addEventListener\n      // On\n      const isSupported = element && element.addEventListener;\n      if (!isSupported) return;\n\n      // Create event listener that calls handler function stored in ref\n      const eventListener = event => savedHandler.current(event);\n\n      // Add event listener\n      element.addEventListener(eventName, eventListener);\n\n      // Remove event listener on cleanup\n      return () => {\n        element.removeEventListener(eventName, eventListener);\n      };\n    },\n    [eventName, element] // Re-run if eventName or element changes\n  );\n};","import React, { useEffect, useContext, useCallback, useRef } from \"react\";\nimport useEventListener from \"../hooks/useEventListener\";\nimport useSmallSize from \"../hooks/useSmallSize\";\nimport ThemeContext from \"../context/ThemeContext\";\n\nexport default () => {\n  const size = useSmallSize();\n  const canvas = useRef(null);\n  const requestRef = useRef();\n  const { dark } = useContext(ThemeContext);\n\n  useEffect(() => {\n    requestRef.current = requestAnimationFrame(animationLoop);\n    return () => cancelAnimationFrame(requestRef.current);\n  }); // Make sure the effect runs only once\n\n  // Ball\n  const ballRadius = 10;\n  let dx = 4;\n  let dy = -4;\n  let x = size / 2;\n  let y = size - 200;\n\n  // Paddle\n  let paddleHeight = 20;\n  let paddleWidth = 75;\n  let paddleX = size / 2;\n  let paddleY = 100;\n\n  // Controls\n  let rightPressed = false;\n  let leftPressed = false;\n\n  // Bricks\n  let brickRowCount = 4;\n  let brickColumnCount = 4;\n  let brickWidth = 75;\n  let brickHeight = 20;\n  let brickPadding = 10;\n  let brickOffsetTop = 100;\n  let brickOffsetLeft =\n    size / 2 -\n    ((brickWidth + brickPadding) * brickColumnCount) / 2 +\n    brickPadding / 2;\n\n  // State\n  let score = 0;\n  let lives = 3;\n\n  // Handlers\n  const handleKeyDown = useCallback(({ keyCode }) => {\n    if (keyCode === 39) {\n      rightPressed = true;\n    } else if (keyCode === 37) {\n      leftPressed = true;\n    }\n  }, []);\n\n  const handleKeyUp = useCallback(({ keyCode }) => {\n    if (keyCode === 39) {\n      rightPressed = false;\n    } else if (keyCode === 37) {\n      leftPressed = false;\n    }\n  }, []);\n\n  function handleMouse({ clientX }) {\n    let relativeX = clientX - canvas.current.offsetLeft;\n    if (relativeX > 0 && relativeX < size) {\n      paddleX = relativeX - paddleWidth / 2;\n    }\n  }\n\n  // Add event listener using our hook\n  useEventListener(\"keydown\", handleKeyDown);\n  useEventListener(\"keyup\", handleKeyUp);\n  useEventListener(\"mousemove\", handleMouse);\n\n  function collisionDetection() {\n    for (c = 0; c < brickColumnCount; c++) {\n      for (r = 0; r < brickRowCount; r++) {\n        let b = bricks[c][r];\n        if (b.status === 1) {\n          if (\n            x > b.x &&\n            x < b.x + brickWidth &&\n            y > b.y &&\n            y < b.y + brickHeight\n          ) {\n            dy = -dy;\n            b.status = 0;\n            score++;\n            if (score === brickRowCount * brickColumnCount) {\n              console.log(\"YOU WIN\");\n              document.location.reload();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function drawScore(ctx) {\n    ctx.font = \"bold 30px Inter\";\n    ctx.fillStyle = colors.main;\n    ctx.fillText(score, 35, 40);\n  }\n  function drawLives(ctx) {\n    ctx.fillText(lives, size - 65, 40);\n  }\n\n  // Colors\n  const colors = {\n    main: dark ? \"RGBA(228, 230, 234, 1.00)\" : \"RGBA(62, 62, 62, 1.00)\",\n  };\n\n  let bricks = [];\n  for (var c = 0; c < brickColumnCount; c++) {\n    bricks[c] = [];\n    for (var r = 0; r < brickRowCount; r++) {\n      bricks[c][r] = { x: 0, y: 0, status: 1 };\n    }\n  }\n\n  const drawBall = (ctx) => {\n    ctx.beginPath();\n    ctx.fillStyle = colors.main;\n    ctx.arc(x, y, ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.closePath();\n  };\n\n  const drawPaddle = (ctx) => {\n    ctx.beginPath();\n    ctx.rect(paddleX, size - paddleY, paddleWidth, paddleHeight);\n    ctx.fillStyle = colors.main;\n    ctx.fill();\n    ctx.closePath();\n  };\n\n  const drawBricks = (ctx) => {\n    for (var c = 0; c < brickColumnCount; c++) {\n      for (var r = 0; r < brickRowCount; r++) {\n        if (bricks[c][r].status === 1) {\n          let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;\n          let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;\n          bricks[c][r].x = brickX;\n          bricks[c][r].y = brickY;\n          ctx.beginPath();\n          ctx.rect(brickX, brickY, brickWidth, brickHeight);\n          ctx.fillStyle = colors.main;\n          ctx.fill();\n          ctx.closePath();\n        }\n      }\n    }\n  };\n\n  // DRAW\n  const animationLoop = () => {\n    const ctx = canvas.current.getContext(\"2d\");\n\n    // Scale\n    const ratio = window.devicePixelRatio || 1;\n\n    canvas.current.width = size * ratio;\n    canvas.current.height = size * ratio;\n\n    canvas.current.style.width = `${size}px`;\n    canvas.current.style.height = `${size}px`;\n\n    ctx.scale(ratio, ratio);\n\n\n    ctx.clearRect(0, 0, size, size); // clear canvas\n\n    drawBall(ctx);\n    drawPaddle(ctx);\n    drawBricks(ctx);\n    collisionDetection();\n    drawScore(ctx);\n    drawLives(ctx);\n\n    // Mov\n    x += dx;\n    y += dy;\n\n    if (x + dx > size - ballRadius || x + dx < ballRadius) {\n      dx = -dx;\n    }\n    if (y + dy < ballRadius) {\n      dy = -dy;\n    } else if (y + dy + paddleY > size - ballRadius) {\n      // Paddle\n      if (x > paddleX && x < paddleX + paddleWidth) {\n        dy = -dy;\n      } else {\n        lives--;\n        if (!lives) {\n          console.log(\"GAME OVER\");\n          document.location.reload();\n        } else {\n          x = size / 2;\n          y = size / 2;\n          dx = 3;\n          dy = -3;\n          paddleX = (size - paddleWidth) / 2;\n        }\n      }\n    }\n\n    if (rightPressed && paddleX < size - paddleWidth) {\n      paddleX += 7;\n    } else if (leftPressed && paddleX > 0) {\n      paddleX -= 7;\n    }\n\n    // console.log(y > size - paddleY)\n\n    // Loop\n    requestRef.current = requestAnimationFrame(animationLoop);\n  };\n\n  return (\n    <div\n      style={{\n        width: \"100%\",\n        height: \"100vh\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <canvas\n        style={{\n          size: \"100%\",\n          border: `${paddleHeight}px solid ${colors.main}`,\n        }}\n        ref={canvas}\n        width={size}\n        height={size}\n      />\n    </div>\n  );\n};\n"],"sourceRoot":""}